<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Smart Mirror</title>
    <link rel="stylesheet" href="/static/style.css">
    <script src="/static/gesture_focus.js" defer></script>
</head>
<body>
    <div class="container">

        <div class="toolbar">
            <button data-gfocus data-genter="js:window.history.back()">â¬… Wstecz</button>
            <a data-gfocus data-genter="link" href="/user/asystent_chat">ðŸŽ¤ Asystent</a>
            <button data-gfocus data-genter="js:location.reload()">âŸ³ OdÅ›wieÅ¼</button>
        </div>

        <h1>{{ time }}</h1>
        <p>{{ date }}</p>

        <div class="top-row">
            <div class="weather">
                <img src="https://openweathermap.org/img/wn/{{ weather.icon }}@2x.png" alt="weather">
                <div class="main">
                    <div>{{ weather.temp }}Â°C</div>
                    <div style="font-size:0.9rem; opacity:0.85;">{{ weather.desc }}</div>
                </div>
            </div>

            <div class="weather">
                <div class="main">
                    {# â€” bezpieczne wartoÅ›ci startowe â€” #}
                    {% set has_t = (temperatura is not none) %}
                    {% set has_h = (wilgotnosc  is not none) %}
                    {% set tval = (temperatura|round(1)) if has_t else '?' %}
                    {% set hval = (wilgotnosc|round(0))  if has_h else '?' %}

                    <div id="sensor-line" style="{{ '' if (has_t or has_h) else 'display:none' }}">
                        <span id="temp-val">{{ tval }}</span>Â°C  /  <span id="hum-val">{{ hval }}</span>%
                    </div>
                    <div id="sensor-nodata" style="{{ 'display:none' if (has_t or has_h) else '' }}">
                        Brak danych
                    </div>

                    <div style="font-size:0.9rem; opacity:0.85;">Zmierzona temperatura i wilgotnoÅ›Ä‡</div>
                </div>
            </div>
        </div>

        <h3>Prognoza na dziÅ›:</h3>
        <div class="forecast-container">
            {% for item in forecast %}
                <div class="forecast-item">
                    <p><strong>{{ item.time }}</strong></p>
                    <img src="https://openweathermap.org/img/wn/{{ item.icon }}@2x.png" alt="{{ item.desc }}">
                    <p>{{ item.temp }}Â°C</p>
                    <p>{{ item.desc }}</p>
                </div>
            {% endfor %}
        </div>

        <h2>Dzisiaj:</h2>
        <ul>
            {% for event in today_events %}
                <li>
                {% if event.time %}
                    {{ event.time }} â€“ {{ event.title }}
                {% else %}
                    {{ event.title }}
                {% endif %}
                </li>
            {% else %}
                <li>Brak wydarzeÅ„ na dziÅ›</li>
            {% endfor %}
        </ul>

        <h2>PrzyszÅ‚e:</h2>
        <ul>
            {% for event in future_events %}
                <li>
                    {{ event.date_str }}
                    {% if event.time %}
                        {{ event.time }} â€“
                    {% endif %}
                    {{ event.title }}
                </li>
            {% else %}
                <li>Brak nadchodzÄ…cych wydarzeÅ„</li>
            {% endfor %}
        </ul>

        <h2>Zadania:</h2>
        <ul>
            {% for task in tasks %}
                <li>{{ task.due }} â€“ {{ task.title }}</li>
            {% else %}
                <li>Brak zadaÅ„</li>
            {% endfor %}
        </ul>
    </div>

    <script>
    // Hotword â†’ przejÅ›cie do asystenta
    let hotwordDetected = false;
    const hotwordInterval = setInterval(() => {
        if (hotwordDetected) return;

        fetch('/check_hotword')
            .then(r => r.json())
            .then(data => {
                if (data.detected === true) {
                    hotwordDetected = true;
                    clearInterval(hotwordInterval);
                    window.location.href = '/user/asystent_chat';
                }
            })
            .catch(err => console.error("BÅ‚Ä…d fetch:", err));
    }, 1000);

    // Auto-odÅ›wieÅ¼anie czujnika iNode (adaptacyjne: szybko do pierwszych danych, potem rzadziej)
    let sensorsHaveData = false;
    let sensorsTimer = null;

    function scheduleSensorsPolling(ms) {
        if (sensorsTimer) clearInterval(sensorsTimer);
        sensorsTimer = setInterval(refreshSensors, ms);
    }

    async function refreshSensors() {
        try {
            const res = await fetch('/api/sensors', { cache: 'no-store' });
            if (!res.ok) return;
            const data = await res.json();
            const t = data.t, h = data.h;

            const line  = document.getElementById('sensor-line');
            const nodata = document.getElementById('sensor-nodata');
            const tEl = document.getElementById('temp-val');
            const hEl = document.getElementById('hum-val');

            const hasT = (t !== null && t !== undefined && !Number.isNaN(t));
            const hasH = (h !== null && h !== undefined && !Number.isNaN(h));

            if (hasT || hasH) {
                if (line)   line.style.display = '';
                if (nodata) nodata.style.display = 'none';
                if (tEl) tEl.textContent = hasT ? (Math.round(t * 10) / 10).toFixed(1) : '?';
                if (hEl) hEl.textContent = hasH ? Math.round(h).toString() : '?';

                // Gdy po raz pierwszy dostaliÅ›my dane â†’ przeÅ‚Ä…cz na rzadkie odpytywanie
                if (!sensorsHaveData) {
                    sensorsHaveData = true;
                    scheduleSensorsPolling(30000); // co 30s po pierwszym sukcesie
                }
            } else {
                if (line)   line.style.display = 'none';
                if (nodata) nodata.style.display = '';
                // JeÅ›li (z jakiegoÅ› powodu) znÃ³w brak danych, wrÃ³Ä‡ do szybkiego trybu
                if (sensorsHaveData) {
                    sensorsHaveData = false;
                    scheduleSensorsPolling(2000);
                }
            }
        } catch (e) {
            console.error('BÅ‚Ä…d /api/sensors:', e);
        }
    }

    // Start: od razu prÃ³bujemy i co 2s do skutku, potem co 30s
    refreshSensors();           // natychmiast
    scheduleSensorsPolling(2000); // szybko, dopÃ³ki nie dostaniemy pierwszych wartoÅ›ci
    // pierwszy strzaÅ‚ szybko po zaÅ‚adowaniu, potem co 30 s
    setTimeout(refreshSensors, 1000);
    setInterval(refreshSensors, 30000);
    </script>
</body>
</html>
